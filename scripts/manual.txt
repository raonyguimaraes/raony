apg
b"APG(1)                                               User Manual                                               APG(1)\n\nNAME\n       apg - generates several random passwords\n\nSYNOPSIS\n       apg  [-a  algorithm] [-M mode] [-E char_string] [-n num_of_pass] [-m min_pass_len] [-x max_pass_len] [-r dict\xe2\x80\x90\n       file] [-b filter_file] [-p min_substr_len] [-s] [-c cl_seed] [-d] [-y] [-l] [-t] [-q] [-h] [-v]\n\nDESCRIPTION\n       apg generates several random passwords. It uses several password generation algorithms (currently two)  and  a\n       built-in pseudo random number generator.\n\n       Default  algorithm is pronounceable password generation algorithm designed by Morrie Gasser and described in A\n       Random Word Generator For Pronounceable Passwords National Technical Information Service  (NTIS)  AD-A-017676.\n       The  original  paper is very old and had never been put online, so I have to use NIST implementation described\n       in FIPS-181.\n\n       Another algorithm is simple random character generation algorithm, but it uses four user-defined  symbol  sets\n       to produce random password. It means that user can choose type of symbols that should appear in password. Sym\xe2\x80\x90\n       bol sets are: numeric symbol set (0,...,9), capital letters symbol set (A,...,Z),  small  letters  symbol  set\n       (a,...,z) and special symbols symbol set (#,@,!,...).\n\n       Built-in  pseudo  random  number  generator  is an implementation of algorithm described in Appendix C of ANSI\n       X9.17 or RFC 1750 with exception that it uses CAST or SHA-1 instead of Triple DES.  It uses  local  time  with\n       precision of microseconds (see gettimeofday(2)) and /dev/random (if available) to produce initial random seed.\n\n       apg  also  have  the ability to check generated password quality using dictionary. You can use this ability if\n       you specify command-line options -r dictfile or -b filtername where dictfile is the dictionary file  name  and\n       filtername is the name of Bloom filter file. In that dictionary you may place words (one per line) that should\n       not appear as generated passwords. For example: user names, common words, etc. You even can  use  one  of  the\n       dictionaries  that come with dictionary password crackers.  Bloom filter file should be created with apgbfm(1)\n       utility included in apg distribution. In future releases I plan to implement some other  techniques  to  check\n       passwords (like pattern check) just to make life easier.\n\nOPTIONS\n   Password generation modes options\n       -a algorithm\n              Use algorithm for password generation.\n              0 - pronounceable password generation (default)\n              1 - random character password generation\n\n       -n num_of_pass\n              Generate num_of_pass number of passwords. Default is 6.\n\n       -m min_pass_len\n              Generate password with minimum length min_pass_len.  If min_pass_len > max_pass_len then max_pass_len =\n              min_pass_len.  Default minimum password length is 8.\n\n       -x max_pass_len\n              Generate password with maximum length max_pass_len.  If min_pass_len > max_pass_len then max_pass_len =\n              min_pass_len.  Default maximum password length is 10.\n\n       -M mode\n              Use  symbolsets specified with mode for password generation.  mode is a text string consisting of char\xe2\x80\x90\n              acters S, s, N, n, C, c, L, l. Where:\n\n              S      Generator must use special symbol set for every generated password.\n\n              s      Generator should use special symbol set for password generation.\n\n              N      Generator must use numeral symbol set for every generated password.\n\n              n      Generator should use numeral symbol set for password generation.\n\n              C      Generator must use capital symbol set for every generated password.\n\n              c      Generator should use capital symbol set for password generation.\n\n              L      Generator must use small letters symbol set for every generated password (always present if pro\xe2\x80\x90\n                     nounceable password generation algorithm is used).\n\n              l      Generator should use small letters symbol set for password generation.\n\n              R,r    Not supported any more. Use -E char_string option instead.\n              mode can not be more than 4 characters in length.\n\n              Note:\n              Usage of L, M, S, C will slow down password generation process.\n\n              Examples:\n              -M sncl\n              -M SNCL\n              -M Cn\n\n       -E char_string\n              Exclude  characters  in char_string from password generation process (in pronounceable password genera\xe2\x80\x90\n              tion mode you can not exclude small letters). To include special symbols  that  can  be  recognized  by\n              shell (apostrophe, quotes, dollar sign, etc.) in char_string use the backslashed versions.\n\n              Examples:\n\n              Command apg -a 1 -M n -n 3 -m 8 -E 23456789 will generate a set of passwords that will look like this:\n              10100110\n              01111000\n              11011101\n\n              Command  apg  -a  1 -M nc -n 3 -m 26 -E GHIJKLMNOPQRSTUVWXYZ will generate a set of passwords that will\n              look like this:\n              16A1653CD4DE5E7BD9584A3476\n              C8F78E06944AFD57FB9CB882BC\n              8C8DF37CD792D36D056BBD5002\n\n   Password quality control options\n       -r dictfile\n              Check generated passwords for their appearance in dictfile\n\n       -b filter_file\n              Check generated passwords for their appearance in filter_file. filter_file should be created  with  the\n              apgbfm(1) utility.\n\n       -p min_substr_len\n              This  option  tells  apg(1)  to  check every substring of the generated password for appearance in fil\xe2\x80\x90\n              ter_file. If any of such substrings would be found in the filter_file then generated password would  be\n              rejected  and  apg(1)  will generate another one.  min_substr_len specifies minimum substring length to\n              check.  This option is active only if -b option is defined.\n\n   Pseudo random number generator options\n       -s     Ask user for random sequence for password generation\n\n       -c cl_seed\n              Use cl_seed as a random seed for password generation. I use it when i have to generate passwords  in  a\n              shell script.\n              Examples:\n              -c /dev/urandom\n              -c /tmp/seed_file\n\n   Password output options\n       -d     Do  NOT use any delimiters between generated passwords. I use it when i have to generate passwords in a\n              shell script.\n\n       -y     Print generated passwords and crypted passwords (see crypt(3))\n\n       -q     Quiet mode (do not print warnings)\n\n       -l     Spell generated passwords. Useful when you want to read generated password by telephone.\n              WARNING: Think twice before read your password by phone.\n\n       -t     Print pronunciation for generated pronounceable password. Ignored if -a 1 is set.\n\n       -h     Print help information and exit\n\n       -v     Print version information and exit\n\nDEFAULT OPTIONS\n       apg -a 0 -M sncl -n 6 -x 10 -m 8 (new style)\n\n       If you want to generate really secure passwords, you should use option -s. To  simplify  apg  usage,  you  can\n       write a small shell script. For example:\n       [begin]----> pwgen.sh\n       #!/bin/sh\n       /usr/local/bin/apg -m 8 -x 12 -s\n       [ end ]----> pwgen.sh\n\nEXIT CODE\n       On  successful  completion  of  its task, apg will complete with exit code 0.  An exit code of -1 indicates an\n       error occurred.  Textual errors are written to the standard error stream.\n\nDIAGNOSTICS\n       If /dev/random is not available, apg will display a message about it.\n\nFILES\n       None.\n\nBUGS\n       None.  If you've found one, please send bug description to the author.\n\nSEE ALSO\n       apgbfm(1)\n\nAUTHOR\n       Adel I. Mirzazhanov, <a-del@iname.com>\n       Project home page: http://www.adel.nursat.kz/apg/\n\nAutomated Password Generator                         2003 Aug 04                                               APG(1)\n"
apt
b"APT(8)                                                   APT                                                   APT(8)\n\nNAME\n       apt - command-line interface\n\nSYNOPSIS\n       apt [-h] [-o=config_string] [-c=config_file] [-t=target_release] [-a=architecture] {list | search | show |\n           update | install pkg [{=pkg_version_number | /target_release}]...  | remove pkg...  | upgrade |\n           full-upgrade | edit-sources | {-v | --version} | {-h | --help}}\n\nDESCRIPTION\n       apt provides a high-level commandline interface for the package management system. It is intended as an end\n       user interface and enables some options better suited for interactive usage by default compared to more\n       specialized APT tools like apt-get(8) and apt-cache(8).\n\n       Much like apt itself, its manpage is intended as an end user interface and as such only mentions the most used\n       commands and options partly to not duplicate information in multiple places and partly to avoid overwhelming\n       readers with a cornucopia of options and details.\n\n       update (apt-get(8))\n           update is used to download package information from all configured sources. Other commands operate on this\n           data to e.g. perform package upgrades or search in and display details about all packages available for\n           installation.\n\n       upgrade (apt-get(8))\n           upgrade is used to install available upgrades of all packages currently installed on the system from the\n           sources configured via sources.list(5). New packages will be installed if required to satisfy\n           dependencies, but existing packages will never be removed. If an upgrade for a package requires the\n           removal of an installed package the upgrade for this package isn't performed.\n\n       full-upgrade (apt-get(8))\n           full-upgrade performs the function of upgrade but will remove currently installed packages if this is\n           needed to upgrade the system as a whole.\n\n       install, remove, purge (apt-get(8))\n           Performs the requested action on one or more packages specified via regex(7), glob(7) or exact match. The\n           requested action can be overridden for specific packages by append a plus (+) to the package name to\n           install this package or a minus (-) to remove it.\n\n           A specific version of a package can be selected for installation by following the package name with an\n           equals (=) and the version of the package to select. Alternatively the version from a specific release can\n           be selected by following the package name with a forward slash (/) and codename (stretch, buster, sid ...)\n           or suite name (stable, testing, unstable). This will also select versions from this release for\n           dependencies of this package if needed to satisfy the request.\n\n           Removing a package removes all packaged data, but leaves usually small (modified) user configuration files\n           behind, in case the remove was an accident. Just issuing an installation request for the accidentally\n           removed package will restore its function as before in that case. On the other hand you can get rid of\n           these leftovers by calling purge even on already removed packages. Note that this does not affect any data\n           or configuration stored in your home directory.\n\n       autoremove (apt-get(8))\n           autoremove is used to remove packages that were automatically installed to satisfy dependencies for other\n           packages and are now no longer needed as dependencies changed or the package(s) needing them were removed\n           in the meantime.\n\n           You should check that the list does not include applications you have grown to like even though they were\n           once installed just as a dependency of another package. You can mark such a package as manually installed\n           by using apt-mark(8). Packages which you have installed explicitly via install are also never proposed for\n           automatic removal.\n\n       search (apt-cache(8))\n           search can be used to search for the given regex(7) term(s) in the list of available packages and display\n           matches. This can e.g. be useful if you are looking for packages having a specific feature. If you are\n           looking for a package including a specific file try apt-file(1).\n\n       show (apt-cache(8))\n           Show information about the given package(s) including its dependencies, installation and download size,\n           sources the package is available from, the description of the packages content and much more. It can e.g.\n           be helpful to look at this information before allowing apt(8) to remove a package or while searching for\n           new packages to install.\n\n       list (work-in-progress)\n           list is somewhat similar to dpkg-query --list in that it can display a list of packages satisfying certain\n           criteria. It supports glob(7) patterns for matching package names as well as options to list installed\n           (--installed), upgradeable (--upgradeable) or all available (--all-versions) versions.\n\n       edit-sources (work-in-progress)\n           edit-sources lets you edit your sources.list(5) files in your preferred texteditor while also providing\n           basic sanity checks.\n\nSCRIPT USAGE AND DIFFERENCES FROM OTHER APT TOOLS\n       The apt(8) commandline is designed as an end-user tool and it may change behavior between versions. While it\n       tries not to break backward compatibility this is not guaranteed either if a change seems beneficial for\n       interactive use.\n\n       All features of apt(8) are available in dedicated APT tools like apt-get(8) and apt-cache(8) as well.  apt(8)\n       just changes the default value of some options (see apt.conf(5) and specifically the Binary scope). So you\n       should prefer using these commands (potentially with some additional options enabled) in your scripts as they\n       keep backward compatibility as much as possible.\n\nSEE ALSO\n       apt-get(8), apt-cache(8), sources.list(5), apt.conf(5), apt-config(8), The APT User's guide in\n       /usr/share/doc/apt-doc/, apt_preferences(5), the APT Howto.\n\nDIAGNOSTICS\n       apt returns zero on normal operation, decimal 100 on error.\n\nBUGS\n       APT bug page[1]. If you wish to report a bug in APT, please see /usr/share/doc/debian/bug-reporting.txt or the\n       reportbug(1) command.\n\nAUTHOR\n       APT team\n\nNOTES\n        1. APT bug page\n           http://bugs.debian.org/src:apt\n\nAPT 1.8.0~alpha2ubuntu1                            20 October 2015                                             APT(8)\n"
arp
b"ARP(8)                                   Linux System Administrator's Manual                                   ARP(8)\n\nNAME\n       arp - manipulate the system ARP cache\n\nSYNOPSIS\n       arp [-vn] [-H type] [-i if] [-ae] [hostname]\n\n       arp [-v] [-i if] -d hostname [pub]\n\n       arp [-v] [-H type] [-i if] -s hostname hw_addr [temp]\n\n       arp [-v] [-H type] [-i if] -s hostname hw_addr [netmask nm] pub\n\n       arp [-v] [-H type] [-i if] -Ds hostname ifname [netmask nm] pub\n\n       arp [-vnD] [-H type] [-i if] -f [filename]\n\nDESCRIPTION\n       Arp manipulates or displays the kernel's IPv4 network neighbour cache. It can add entries to the table, delete\n       one or display the current content.\n\n       ARP stands for Address Resolution Protocol, which is used to find the media access control address of  a  net\xe2\x80\x90\n       work neighbour for a given IPv4 Address.\n\nMODES\n       arp  with no mode specifier will print the current content of the table. It is possible to limit the number of\n       entries printed, by specifying an hardware address type, interface name or host address.\n\n       arp -d address will delete a ARP table entry. Root or netadmin privilege is required to do this. The entry  is\n       found by IP address. If a hostname is given, it will be resolved before looking up the entry in the ARP table.\n\n       arp  -s  address hw_addr is used to set up a new table entry. The format of the hw_addr parameter is dependent\n       on the hardware class, but for most classes one can assume that the usual presentation can be used.   For  the\n       Ethernet  class,  this  is 6 bytes in hexadecimal, separated by colons. When adding proxy arp entries (that is\n       those with the publish flag set) a netmask may be specified to proxy arp for entire subnets. This is not  good\n       practice, but is supported by older kernels because it can be useful. If the temp flag is not supplied entries\n       will be permanent stored into the ARP cache. To simplify setting up entries for one of your own network inter\xe2\x80\x90\n       faces, you can use the arp -Ds address ifname form. In that case the hardware address is taken from the inter\xe2\x80\x90\n       face with the specified name.\n\nOPTIONS\n       -v, --verbose\n              Tell the user what is going on by being verbose.\n\n       -n, --numeric\n              shows numerical addresses instead of trying to determine symbolic host, port or user names.\n\n       -H type, --hw-type type, -t type\n              When setting or reading the ARP cache, this optional parameter tells arp  which  class  of  entries  it\n              should check for.  The default value of this parameter is ether (i.e. hardware code 0x01 for IEEE 802.3\n              10Mbps Ethernet).  Other values might include network technologies such as  ARCnet  (arcnet)  ,  PROnet\n              (pronet) , AX.25 (ax25) and NET/ROM (netrom).\n\n       -a     Use alternate BSD style output format (with no fixed columns).\n\n       -e     Use default Linux style output format (with fixed columns).\n\n       -D, --use-device\n              Instead  of a hw_addr, the given argument is the name of an interface.  arp will use the MAC address of\n              that interface for the table entry. This is usually the best option to set up  a  proxy  ARP  entry  to\n              yourself.\n\n       -i If, --device If\n              Select  an  interface. When dumping the ARP cache only entries matching the specified interface will be\n              printed. When setting a permanent or temp ARP entry this interface will be associated with  the  entry;\n              if this option is not used, the kernel will guess based on the routing table. For pub entries the spec\xe2\x80\x90\n              ified interface is the interface on which ARP requests will be answered.\n              NOTE: This has to be different from the interface to which the IP datagrams will be routed.   NOTE:  As\n              of  kernel  2.2.0 it is no longer possible to set an ARP entry for an entire subnet. Linux instead does\n              automagic proxy arp when a route exists and it is forwarding. See arp(7) for details. Also the  dontpub\n              option which is available for delete and set operations cannot be used with 2.4 and newer kernels.\n\n       -f filename, --file filename\n              Similar  to  the  -s  option, only this time the address info is taken from file filename.  This can be\n              used if ARP entries for a lot of hosts have to be set up.  The name of the  data  file  is  very  often\n              /etc/ethers, but this is not official. If no filename is specified /etc/ethers is used as default.\n\n              The  format  of  the  file is simple; it only contains ASCII text lines with a hostname, and a hardware\n              address separated by whitespace. Additionally the pub, temp and netmask flags can be used.\n\n       In all places where a hostname is expected, one can also enter an IP address in dotted-decimal notation.\n\n       As a special case for compatibility the order of the hostname and the hardware address can be exchanged.\n\n       Each complete entry in the ARP cache will be marked with the C flag. Permanent entries are marked with  M  and\n       published entries have the P flag.\n\nEXAMPLES\n       /usr/sbin/arp -i eth0 -Ds 10.0.0.2 eth1 pub\n\n       This will answer ARP requests for 10.0.0.2 on eth0 with the MAC address for eth1.\n\n       /usr/sbin/arp -i eth1 -d 10.0.0.1\n\n       Delete  the  ARP  table  entry for 10.0.0.1 on interface eth1. This will match published proxy ARP entries and\n       permanent entries.\n\nFILES\n       /proc/net/arp\n       /etc/networks\n       /etc/hosts\n       /etc/ethers\n\nSEE ALSO\n       rarp(8), route(8), ifconfig(8), netstat(8)\n\nAUTHORS\n       Fred N. van Kempen <waltje@uwalt.nl.mugnet.org>, Bernd Eckenfels <net-tools@lina.inka.de>.\n\nnet-tools                                             2008-10-03                                               ARP(8)\n"
awk
b'GAWK(1)                                            Utility Commands                                           GAWK(1)\n\nNAME\n       gawk - pattern scanning and processing language\n\nSYNOPSIS\n       gawk [ POSIX or GNU style options ] -f program-file [ -- ] file ...\n       gawk [ POSIX or GNU style options ] [ -- ] program-text file ...\n\nDESCRIPTION\n       Gawk  is  the  GNU Project\'s implementation of the AWK programming language.  It conforms to the definition of\n       the language in the POSIX 1003.1 standard.  This version in turn is based on the description in The  AWK  Pro\xe2\x80\x90\n       gramming Language, by Aho, Kernighan, and Weinberger.  Gawk provides the additional features found in the cur\xe2\x80\x90\n       rent version of Brian Kernighan\'s awk and numerous GNU-specific extensions.\n\n       The command line consists of options to gawk itself, the AWK program text (if not supplied via the  -f  or  -i\n       options), and values to be made available in the ARGC and ARGV pre-defined AWK variables.\n\n       When gawk is invoked with the --profile option, it starts gathering profiling statistics from the execution of\n       the program.  Gawk runs more slowly in this mode, and automatically produces an execution profile in the  file\n       awkprof.out when done.  See the --profile option, below.\n\n       Gawk also has an integrated debugger. An interactive debugging session can be started by supplying the --debug\n       option to the command line. In this mode of execution, gawk loads the AWK source code  and  then  prompts  for\n       debugging commands.  Gawk can only debug AWK program source provided with the -f option.  The debugger is doc\xe2\x80\x90\n       umented in GAWK: Effective AWK Programming.\n\nOPTION FORMAT\n       Gawk options may be either traditional POSIX-style one letter  options,  or  GNU-style  long  options.   POSIX\n       options  start with a single \xe2\x80\x9c-\xe2\x80\x9d, while long options start with \xe2\x80\x9c--\xe2\x80\x9d.  Long options are provided for both GNU-\n       specific features and for POSIX-mandated features.\n\n       Gawk-specific options are typically used in long-option form.  Arguments to long  options  are  either  joined\n       with  the  option  by  an = sign, with no intervening spaces, or they may be provided in the next command line\n       argument.  Long options may be abbreviated, as long as the abbreviation remains unique.\n\n       Additionally, every long option has a corresponding short option, so that the option\'s  functionality  may  be\n       used from within #!  executable scripts.\n\nOPTIONS\n       Gawk  accepts  the  following options.  Standard options are listed first, followed by options for gawk exten\xe2\x80\x90\n       sions, listed alphabetically by short option.\n\n       -f program-file\n       --file program-file\n              Read the AWK program source from the file program-file, instead of from the first  command  line  argu\xe2\x80\x90\n              ment.  Multiple -f (or --file) options may be used.\n\n       -F fs\n       --field-separator fs\n              Use fs for the input field separator (the value of the FS predefined variable).\n\n       -v var=val\n       --assign var=val\n              Assign the value val to the variable var, before execution of the program begins.  Such variable values\n              are available to the BEGIN rule of an AWK program.\n\n       -b\n       --characters-as-bytes\n              Treat all input data as single-byte characters. In other words, don\'t pay any attention to  the  locale\n              information  when  attempting to process strings as multibyte characters.  The --posix option overrides\n              this one.\n\n       -c\n       --traditional\n              Run in compatibility mode.  In compatibility mode, gawk behaves identically to Brian  Kernighan\'s  awk;\n              none of the GNU-specific extensions are recognized.  See GNU EXTENSIONS, below, for more information.\n\n       -C\n       --copyright\n              Print  the  short version of the GNU copyright information message on the standard output and exit suc\xe2\x80\x90\n              cessfully.\n\n       -d[file]\n       --dump-variables[=file]\n              Print a sorted list of global variables, their types and final values to file.  If no file is provided,\n              gawk uses a file named awkvars.out in the current directory.\n              Having  a  list of all the global variables is a good way to look for typographical errors in your pro\xe2\x80\x90\n              grams.  You would also use this option if you have a large program with a lot  of  functions,  and  you\n              want  to  be  sure  that  your  functions don\'t inadvertently use global variables that you meant to be\n              local.  (This is a particularly easy mistake to make with simple variable names like i, j, and so on.)\n\n       -D[file]\n       --debug[=file]\n              Enable debugging of AWK programs.  By default, the debugger reads commands interactively from the  key\xe2\x80\x90\n              board  (standard  input).   The optional file argument specifies a file with a list of commands for the\n              debugger to execute non-interactively.\n\n       -e program-text\n       --source program-text\n              Use program-text as AWK program source code.  This option allows the easy intermixing of library  func\xe2\x80\x90\n              tions  (used  via  the -f and -i options) with source code entered on the command line.  It is intended\n              primarily for medium to large AWK programs used in shell scripts.\n\n       -E file\n       --exec file\n              Similar to -f, however, this is option is the  last  one  processed.   This  should  be  used  with  #!\n              scripts,  particularly for CGI applications, to avoid passing in options or source code (!) on the com\xe2\x80\x90\n              mand line from a URL.  This option disables command-line variable assignments.\n\n       -g\n       --gen-pot\n              Scan and parse the AWK program, and generate a GNU .pot (Portable Object Template) format file on stan\xe2\x80\x90\n              dard  output  with  entries for all localizable strings in the program.  The program itself is not exe\xe2\x80\x90\n              cuted.  See the GNU gettext distribution for more information on .pot files.\n\n       -h\n       --help Print a relatively short summary of the available options on the standard output.  (Per the GNU  Coding\n              Standards, these options cause an immediate, successful exit.)\n\n       -i include-file\n       --include include-file\n              Load  an awk source library.  This searches for the library using the AWKPATH environment variable.  If\n              the initial search fails, another attempt will be made after appending the .awk suffix.  The file  will\n              be  loaded  only once (i.e., duplicates are eliminated), and the code does not constitute the main pro\xe2\x80\x90\n              gram source.\n\n       -l lib\n       --load lib\n              Load a gawk extension from the shared library lib.  This searches for the library using the  AWKLIBPATH\n              environment  variable.   If  the initial search fails, another attempt will be made after appending the\n              default shared library suffix for the platform.  The library initialization routine is expected  to  be\n              named dl_load().\n\n       -L [value]\n       --lint[=value]\n              Provide  warnings about constructs that are dubious or non-portable to other AWK implementations.  With\n              an optional argument of fatal, lint warnings become fatal errors.  This may be  drastic,  but  its  use\n              will  certainly  encourage  the  development  of  cleaner  AWK  programs.  With an optional argument of\n              invalid, only warnings about things that are actually invalid are issued. (This  is  not  fully  imple\xe2\x80\x90\n              mented yet.)\n\n       -M\n       --bignum\n              Force  arbitrary  precision arithmetic on numbers. This option has no effect if gawk is not compiled to\n              use the GNU MPFR and MP libraries.  (In such a case, gawk issues a warning.)\n\n       -n\n       --non-decimal-data\n              Recognize octal and hexadecimal values in input data.  Use this option with great caution!\n\n       -N\n       --use-lc-numeric\n              Force gawk to use the locale\'s decimal point character when parsing input  data.   Although  the  POSIX\n              standard  requires  this behavior, and gawk does so when --posix is in effect, the default is to follow\n              traditional behavior and use a period as the decimal point, even in locales where the period is not the\n              decimal  point  character.   This  option  overrides  the  default behavior, without the full draconian\n              strictness of the --posix option.\n\n       -o[file]\n       --pretty-print[=file]\n              Output a pretty printed version of the program to file.  If no file is provided, gawk uses a file named\n              awkprof.out in the current directory.  Implies --no-optimize.\n\n       -O\n       --optimize\n              Enable  gawk\'s  default optimizations upon the internal representation of the program.  Currently, this\n              includes simple constant-folding, and tail call elimination for recursive functions.  This option is on\n              by default.\n\n       -p[prof-file]\n       --profile[=prof-file]\n              Start  a profiling session, and send the profiling data to prof-file.  The default is awkprof.out.  The\n              profile contains execution counts of each statement in the program in the left margin and function call\n              counts for each user-defined function.  Implies --no-optimize.\n\n       -P\n       --posix\n              This turns on compatibility mode, with the following additional restrictions:\n\n              \xc2\xb7 \\x escape sequences are not recognized.\n\n              \xc2\xb7 You cannot continue lines after ?  and :.\n\n              \xc2\xb7 The synonym func for the keyword function is not recognized.\n\n              \xc2\xb7 The operators ** and **= cannot be used in place of ^ and ^=.\n\n       -r\n       --re-interval\n              Enable the use of interval expressions in regular expression matching (see Regular Expressions, below).\n              Interval expressions were not traditionally available in the AWK language.  The  POSIX  standard  added\n              them,  to  make awk and egrep consistent with each other.  They are enabled by default, but this option\n              remains for use with --traditional.\n\n       -s\n       --no-optimize\n              Disable gawk\'s default optimizations upon the internal representation of the program.\n\n       -S\n       --sandbox\n              Run gawk in sandbox mode, disabling the system() function, input redirection with getline, output redi\xe2\x80\x90\n              rection  with  print and printf, and loading dynamic extensions.  Command execution (through pipelines)\n              is also disabled.  This effectively blocks a script from accessing  local  resources,  except  for  the\n              files specified on the command line.\n\n       -t\n       --lint-old\n              Provide warnings about constructs that are not portable to the original version of UNIX awk.\n\n       -V\n       --version\n              Print  version  information  for  this  particular copy of gawk on the standard output.  This is useful\n              mainly for knowing if the current copy of gawk on your system is up to date with  respect  to  whatever\n              the  Free  Software Foundation is distributing.  This is also useful when reporting bugs.  (Per the GNU\n              Coding Standards, these options cause an immediate, successful exit.)\n\n       --     Signal the end of options. This is useful to allow further arguments to the AWK program itself to start\n              with  a  \xe2\x80\x9c-\xe2\x80\x9d.   This provides consistency with the argument parsing convention used by most other POSIX\n              programs.\n\n       In compatibility mode, any other options are flagged as invalid, but are otherwise ignored.  In normal  opera\xe2\x80\x90\n       tion,  as long as program text has been supplied, unknown options are passed on to the AWK program in the ARGV\n       array for processing.  This is particularly useful for running AWK programs via the #!  executable interpreter\n       mechanism.\n\n       For POSIX compatibility, the -W option may be used, followed by the name of a long option.\n\nAWK PROGRAM EXECUTION\n       An AWK program consists of a sequence of optional directives, pattern-action statements, and optional function\n       definitions.\n\n              @include "filename"\n              @load "filename"\n              pattern   { action statements }\n              function name(parameter list) { statements }\n\n       Gawk first reads the program source from the program-file(s) if specified, from arguments to --source, or from\n       the  first non-option argument on the command line.  The -f and --source options may be used multiple times on\n       the command line.  Gawk reads the program text as if all the program-files and command line source  texts  had\n       been concatenated together.  This is useful for building libraries of AWK functions, without having to include\n       them in each new AWK program that uses them.  It also provides the ability to mix library functions with  com\xe2\x80\x90\n       mand line programs.\n\n       In addition, lines beginning with @include may be used to include other source files into your program, making\n       library use even easier.  This is equivalent to using the -i option.\n\n       Lines beginning with @load may be used to load extension functions into your program.  This is  equivalent  to\n       using the -l option.\n\n       The  environment  variable  AWKPATH specifies a search path to use when finding source files named with the -f\n       and -i options.  If this variable does not exist, the default path is ".:/usr/local/share/awk".   (The  actual\n       directory  may  vary, depending upon how gawk was built and installed.)  If a file name given to the -f option\n       contains a \xe2\x80\x9c/\xe2\x80\x9d character, no path search is performed.\n\n       The environment variable AWKLIBPATH specifies a search path to use when finding source files named with the -l\n       option.   If  this  variable does not exist, the default path is "/usr/local/lib/gawk".  (The actual directory\n       may vary, depending upon how gawk was built and installed.)\n\n       Gawk executes AWK programs in the following order.  First, all  variable  assignments  specified  via  the  -v\n       option are performed.  Next, gawk compiles the program into an internal form.  Then, gawk executes the code in\n       the BEGIN rule(s) (if any), and then proceeds to read each file named in the ARGV array (up to  ARGV[ARGC-1]).\n       If there are no files named on the command line, gawk reads the standard input.\n\n       If  a  filename on the command line has the form var=val it is treated as a variable assignment.  The variable\n       var will be assigned the value val.  (This happens after any BEGIN rule(s) have been run.)  Command line vari\xe2\x80\x90\n       able assignment is most useful for dynamically assigning values to the variables AWK uses to control how input\n       is broken into fields and records.  It is also useful for controlling state if multiple passes are needed over\n       a single data file.\n\n       If the value of a particular element of ARGV is empty (""), gawk skips over it.\n\n       For  each input file, if a BEGINFILE rule exists, gawk executes the associated code before processing the con\xe2\x80\x90\n       tents of the file. Similarly, gawk executes the code associated with ENDFILE after processing the file.\n\n       For each record in the input, gawk tests to see if it matches any pattern in the AWK program.  For  each  pat\xe2\x80\x90\n       tern  that the record matches, gawk executes the associated action.  The patterns are tested in the order they\n       occur in the program.\n\n       Finally, after all the input is exhausted, gawk executes the code in the END rule(s) (if any).\n\n   Command Line Directories\n       According to POSIX, files named on the awk command line must be text files.  The behavior is ``undefined\'\'  if\n       they are not.  Most versions of awk treat a directory on the command line as a fatal error.\n\n       Starting  with  version  4.0  of  gawk,  a  directory on the command line produces a warning, but is otherwise\n       skipped.  If either of the --posix or --traditional options is given, then gawk reverts to  treating  directo\xe2\x80\x90\n       ries on the command line as a fatal error.\n\nVARIABLES, RECORDS AND FIELDS\n       AWK  variables are dynamic; they come into existence when they are first used.  Their values are either float\xe2\x80\x90\n       ing-point numbers or strings, or both, depending upon how they are used.  Additionally, gawk allows  variables\n       to  have regular-expression type.  AWK also has one dimensional arrays; arrays with multiple dimensions may be\n       simulated.  Gawk provides true arrays of arrays; see Arrays, below.  Several pre-defined variables are set  as\n       a program runs; these are described as needed and summarized below.\n\n   Records\n       Normally, records are separated by newline characters.  You can control how records are separated by assigning\n       values to the built-in variable RS.  If RS is any single character, that character separates records.   Other\xe2\x80\x90\n       wise,  RS  is  a  regular  expression.   Text  in the input that matches this regular expression separates the\n       record.  However, in compatibility mode, only the first character of its string value is used  for  separating\n       records.   If  RS is set to the null string, then records are separated by empty lines.  When RS is set to the\n       null string, the newline character always acts as a field separator, in addition  to  whatever  value  FS  may\n       have.\n\n   Fields\n       As  each  input  record is read, gawk splits the record into fields, using the value of the FS variable as the\n       field separator.  If FS is a single character, fields are separated by that character.   If  FS  is  the  null\n       string, then each individual character becomes a separate field.  Otherwise, FS is expected to be a full regu\xe2\x80\x90\n       lar expression.  In the special case that FS is a single space, fields are separated by runs of spaces  and/or\n       tabs  and/or newlines.  NOTE: The value of IGNORECASE (see below) also affects how fields are split when FS is\n       a regular expression, and how records are separated when RS is a regular expression.\n\n       If the FIELDWIDTHS variable is set to a space-separated list of numbers, each field is expected to have  fixed\n       width,  and gawk splits up the record using the specified widths.  Each field width may optionally be preceded\n       by a colon-separated value specifying the number of characters to skip before the field starts.  The value  of\n       FS is ignored.  Assigning a new value to FS or FPAT overrides the use of FIELDWIDTHS.\n\n       Similarly, if the FPAT variable is set to a string representing a regular expression, each field is made up of\n       text that matches that regular expression. In this case, the regular expression  describes  the  fields  them\xe2\x80\x90\n       selves,  instead  of the text that separates the fields.  Assigning a new value to FS or FIELDWIDTHS overrides\n       the use of FPAT.\n\n       Each field in the input record may be referenced by its position: $1, $2, and so on.  $0 is the whole  record.\n       Fields need not be referenced by constants:\n\n              n = 5\n              print $n\n\n       prints the fifth field in the input record.\n\n       The variable NF is set to the total number of fields in the input record.\n\n       References  to  non-existent fields (i.e., fields after $NF) produce the null-string.  However, assigning to a\n       non-existent field (e.g., $(NF+2) = 5) increases the value of NF, creates any intervening fields with the null\n       string  as  their  values, and causes the value of $0 to be recomputed, with the fields being separated by the\n       value of OFS.  References to negative numbered fields cause a fatal error.  Decrementing NF causes the  values\n       of fields past the new value to be lost, and the value of $0 to be recomputed, with the fields being separated\n       by the value of OFS.\n\n       Assigning a value to an existing field causes the whole record to be rebuilt when  $0  is  referenced.   Simi\xe2\x80\x90\n       larly, assigning a value to $0 causes the record to be resplit, creating new values for the fields.\n\n   Built-in Variables\n       Gawk\'s built-in variables are:\n\n       ARGC        The number of command line arguments (does not include options to gawk, or the program source).\n\n       ARGIND      The index in ARGV of the current file being processed.\n\n       ARGV        Array  of  command line arguments.  The array is indexed from 0 to ARGC - 1.  Dynamically changing\n                   the contents of ARGV can control the files used for data.\n\n       BINMODE     On non-POSIX systems, specifies use of \xe2\x80\x9cbinary\xe2\x80\x9d mode for all file I/O.  Numeric values of 1, 2, or\n                   3,  specify  that  input  files,  output files, or all files, respectively, should use binary I/O.\n                   String values of "r", or "w" specify that input files, or output files, respectively,  should  use\n                   binary  I/O.   String  values  of  "rw" or "wr" specify that all files should use binary I/O.  Any\n                   other string value is treated as "rw", but generates a warning message.\n\n       CONVFMT     The conversion format for numbers, "%.6g", by default.\n\n       ENVIRON     An array containing the values of the current environment.  The array is indexed by  the  environ\xe2\x80\x90\n                   ment  variables,  each  element  being  the value of that variable (e.g., ENVIRON["HOME"] might be\n                   "/home/arnold").\n\n                   In POSIX mode, changing this array does not affect the environment seen  by  programs  which  gawk\n                   spawns  via redirection or the system() function.  Otherwise, gawk updates its real environment so\n                   that programs it spawns see the changes.\n\n       ERRNO       If a system error occurs either doing a redirection for getline, during a  read  for  getline,  or\n                   during  a  close(),  then  ERRNO is set to a string describing the error.  The value is subject to\n                   translation in non-English locales.  If the string in ERRNO corresponds to a system error  in  the\n                   errno(3)  variable,  then  the  numeric  value  can be found in PROCINFO["errno"].  For non-system\n                   errors, PROCINFO["errno"] will be zero.\n\n       FIELDWIDTHS A whitespace-separated list of field widths.  When set, gawk parses the input into fields of fixed\n                   width, instead of using the value of the FS variable as the field separator.  Each field width may\n                   optionally be preceded by a colon-separated value specifying the  number  of  characters  to  skip\n                   before the field starts.  See Fields, above.\n\n       FILENAME    The  name  of the current input file.  If no files are specified on the command line, the value of\n                   FILENAME is \xe2\x80\x9c-\xe2\x80\x9d.  However, FILENAME is undefined inside the BEGIN rule (unless set by getline).\n\n       FNR         The input record number in the current input file.\n\n       FPAT        A regular expression describing the contents of the fields in a record.  When set, gawk parses the\n                   input  into  fields,  where the fields match the regular expression, instead of using the value of\n                   the FS variable as the field separator.  See Fields, above.\n\n       FS          The input field separator, a space by default.  See Fields, above.\n\n       FUNCTAB     An array whose indices and corresponding values are the names of all the user-defined or extension\n                   functions in the program.  NOTE: You may not use the delete statement with the FUNCTAB array.\n\n       IGNORECASE  Controls  the case-sensitivity of all regular expression and string operations.  If IGNORECASE has\n                   a non-zero value, then string comparisons and pattern matching in rules, field splitting  with  FS\n                   and  FPAT, record separating with RS, regular expression matching with ~ and !~, and the gensub(),\n                   gsub(), index(), match(), patsplit(), split(), and sub() built-in functions all ignore  case  when\n                   doing  regular  expression  operations.   NOTE:  Array subscripting is not affected.  However, the\n                   asort() and asorti() functions are affected.\n                   Thus, if IGNORECASE is not equal to zero, /aB/ matches all of the strings "ab",  "aB",  "Ab",  and\n                   "AB".   As with all AWK variables, the initial value of IGNORECASE is zero, so all regular expres\xe2\x80\x90\n                   sion and string operations are normally case-sensitive.\n\n       LINT        Provides dynamic control of the --lint option from within an AWK program.  When true, gawk  prints\n                   lint  warnings.  When  false,  it does not.  When assigned the string value "fatal", lint warnings\n                   become fatal errors, exactly like --lint=fatal.  Any other true value just prints warnings.\n\n       NF          The number of fields in the current input record.\n\n       NR          The total number of input records seen so far.\n\n       OFMT        The output format for numbers, "%.6g", by default.\n\n       OFS         The output field separator, a space by default.\n\n       ORS         The output record separator, by default a newline.\n\n       PREC        The working precision of arbitrary precision floating-point numbers, 53 by default.\n\n       PROCINFO    The elements of this array provide access to information about the running AWK program.   On  some\n                   systems,  there  may  be elements in the array, "group1" through "groupn" for some n, which is the\n                   number of supplementary groups that the process has.  Use the in operator to test for  these  ele\xe2\x80\x90\n                   ments.  The following elements are guaranteed to be available:\n\n                   PROCINFO["argv"]     The  command line arguments as received by gawk at the C-language level.  The\n                                        subscripts start from zero.\n\n                   PROCINFO["egid"]     The value of the getegid(2) system call.\n\n                   PROCINFO["errno"]    The value of errno(3) when ERRNO is set to the associated error message.\n\n                   PROCINFO["euid"]     The value of the geteuid(2) system call.\n\n                   PROCINFO["FS"]       "FS" if field splitting with FS is in effect, "FPAT" if field splitting  with\n                                        FPAT  is  in  effect, "FIELDWIDTHS" if field splitting with FIELDWIDTHS is in\n                                        effect, or "API" if API input parser field splitting is in effect.\n\n                   PROCINFO["gid"]      The value of the getgid(2) system call.\n\n                   PROCINFO["identifiers"]\n                                        A subarray, indexed by the names of all identifiers used in the text  of  the\n                                        AWK program.  The values indicate what gawk knows about the identifiers after\n                                        it has finished parsing the program; they are not updated while  the  program\n                                        runs.  For each identifier, the value of the element is one of the following:\n\n                                        "array"     The identifier is an array.\n\n                                        "builtin"   The identifier is a built-in function.\n\n                                        "extension" The identifier is an extension function loaded via @load or -l.\n\n                                        "scalar"    The identifier is a scalar.\n\n                                        "untyped"   The  identifier  is  untyped (could be used as a scalar or array,\n                                                    gawk doesn\'t know yet).\n\n                                        "user"      The identifier is a user-defined function.\n\n                   PROCINFO["pgrpid"]   The process group ID of the current process.\n\n                   PROCINFO["pid"]      The process ID of the current process.\n\n                   PROCINFO["ppid"]     The parent process ID of the current process.\n\n                   PROCINFO["strftime"] The default time format string for strftime().\n\n                   PROCINFO["uid"]      The value of the getuid(2) system call.\n\n                   PROCINFO["version"]  the version of gawk.\n\n                   The following elements are present if loading dynamic extensions is available:\n\n                   PROCINFO["api_major"]\n                          The major version of the extension API.\n\n                   PROCINFO["api_minor"]\n                          The minor version of the extension API.\n\n                   The following elements are available if MPFR support is compiled into gawk:\n\n                   PROCINFO["gmp_version"]\n                          The version of the GNU MP library used for arbitrary precision number support in gawk.\n\n                   PROCINFO["mpfr_version"]\n                          The version of the GNU MPFR library used for arbitrary precision number support in gawk.\n\n                   PROCINFO["prec_max"]\n                          The maximum precision supported by the GNU MPFR library for arbitrary  precision  floating-\n                          point numbers.\n\n                   PROCINFO["prec_min"]\n                          The  minimum  precision  allowed  by the GNU MPFR library for arbitrary precision floating-\n                          point numbers.\n\n                   The following elements may set by a program to change gawk\'s behavior:\n\n                   PROCINFO["NONFATAL"]\n                          If this exists, then I/O errors for all redirections become nonfatal.\n\n                   PROCINFO["ame", "NONFATAL"]\n                          Make I/O errors for name be nonfatal.\n\n                   PROCINFO["command", "pty"]\n                          Use a pseudo-tty for two-way communication with command instead of setting up  two  one-way\n                          pipes.\n\n                   PROCINFO["input", "READ_TIMEOUT"]\n                          The  timeout  in  milliseconds  for  reading  data from input, where input is a redirection\n                          string or a filename. A value of zero or less than zero means no timeout.\n\n                   PROCINFO["input", "RETRY"]\n                          If an I/O error that may be retried occurs when reading data from  input,  and  this  array\n                          entry  exists, then getline returns -2 instead of following the default behavior of return\xe2\x80\x90\n                          ing -1 and configuring input to return no further data.  An I/O error that may  be  retried\n                          is  one where errno(3) has the value EAGAIN, EWOULDBLOCK, EINTR, or ETIMEDOUT.  This may be\n                          useful in conjunction with PROCINFO["input", "READ_TIMEOUT"] or  situations  where  a  file\n                          descriptor has been configured to behave in a non-blocking fashion.\n\n                   PROCINFO["sorted_in"]\n                          If  this  element exists in PROCINFO, then its value controls the order in which array ele\xe2\x80\x90\n                          ments are traversed in for loops.  Supported  values  are  "@ind_str_asc",  "@ind_num_asc",\n                          "@val_type_asc",    "@val_str_asc",   "@val_num_asc",   "@ind_str_desc",   "@ind_num_desc",\n                          "@val_type_desc", "@val_str_desc", "@val_num_desc", and "@unsorted".  The value can also be\n                          the name (as a string) of any comparison function defined as follows:\n\n                               function cmp_func(i1, v1, i2, v2)\n\n                          where i1 and i2 are the indices, and v1 and v2 are the corresponding values of the two ele\xe2\x80\x90\n                          ments being compared.  It should return a number less than, equal to, or  greater  than  0,\n                          depending on how the elements of the array are to be ordered.\n\n       ROUNDMODE   The  rounding  mode to use for arbitrary precision arithmetic on numbers, by default "N" (IEEE-754\n                   roundTiesToEven mode).  The accepted values are "N" or "n" for roundTiesToEven,  "U"  or  "u"  for\n                   roundTowardPositive,  "D"  or  "d" for roundTowardNegative, "Z" or "z" for roundTowardZero, and if\n                   your version of GNU MPFR library supports it, "A" or "a" for rounding away from zero.\n\n       RS          The input record separator, by default a newline.\n\n       RT          The record terminator.  Gawk sets RT to the input text  that  matched  the  character  or  regular\n                   expression specified by RS.\n\n       RSTART      The  index of the first character matched by match(); 0 if no match.  (This implies that character\n                   indices start at one.)\n\n       RLENGTH     The length of the string matched by match(); -1 if no match.\n\n       SUBSEP      The character used to separate multiple subscripts in array elements, by default "\\034".\n\n       SYMTAB      An array whose indices are the names of all currently defined global variables and arrays  in  the\n                   program.  The array may be used for indirect access to read or write the value of a variable:\n\n                        foo = 5\n                        SYMTAB["foo"] = 4\n                        print foo    # prints 4\n\n                   The  typeof()  function  may be used to test if an element in SYMTAB is an array.  You may not use\n                   the delete statement with the SYMTAB array.\n\n       TEXTDOMAIN  The text domain of the AWK program; used to find the  localized  translations  for  the  program\'s\n                   strings.\n\n   Arrays\n       Arrays  are subscripted with an expression between square brackets ([ and ]).  If the expression is an expres\xe2\x80\x90\n       sion list (expr, expr ...)  then the array subscript is a  string  consisting  of  the  concatenation  of  the\n       (string)  value  of  each expression, separated by the value of the SUBSEP variable.  This facility is used to\n       simulate multiply dimensioned arrays.  For example:\n\n              i = "A"; j = "B"; k = "C"\n              x[i, j, k] = "hello, world\\n"\n\n       assigns the string  "hello, world\\n"  to  the  element  of  the  array  x  which  is  indexed  by  the  string\n       "A\\034B\\034C".  All arrays in AWK are associative, i.e., indexed by string values.\n\n       The special operator in may be used to test if an array has an index consisting of a particular value:\n\n              if (val in array)\n                   print array[val]\n\n       If the array has multiple subscripts, use (i, j) in array.\n\n       The  in  construct  may also be used in a for loop to iterate over all the elements of an array.  However, the\n       (i, j) in array construct only works in tests, not in for loops.\n\n       An element may be deleted from an array using the delete statement.  The delete statement may also be used  to\n       delete the entire contents of an array, just by specifying the array name without a subscript.\n\n       gawk supports true multidimensional arrays. It does not require that such arrays be ``rectangular\'\' as in C or\n       C++.  For example:\n\n              a[1] = 5\n              a[2][1] = 6\n              a[2][2] = 7\n\n       NOTE: You may need to tell gawk that an array element is really a subarray in  order  to  use  it  where  gawk\n       expects  an  array (such as in the second argument to split()).  You can do this by creating an element in the\n       subarray and then deleting it with the delete statement.\n\n   Variable Typing And Conversion\n       Variables and fields may be (floating point) numbers, or strings, or both.  They may also be  regular  expres\xe2\x80\x90\n       sions.  How the value of a variable is interpreted depends upon its context.  If used in a numeric expression,\n       it will be treated as a number; if used as a string it will be treated as a string.\n\n       To force a variable to be treated as a number, add zero to it; to force it to be treated as a string, concate\xe2\x80\x90\n       nate it with the null string.\n\n       Uninitialized variables have the numeric value zero and the string value "" (the null, or empty, string).\n\n       When a string must be converted to a number, the conversion is accomplished using strtod(3).  A number is con\xe2\x80\x90\n       verted to a string by using the value of CONVFMT as a format string for sprintf(3), with the numeric value  of\n       the variable as the argument.  However, even though all numbers in AWK are floating-point, integral values are\n       always converted as integers.  Thus, given\n\n              CONVFMT = "%2.2f"\n              a = 12\n              b = a ""\n\n       the variable b has a string value of "12" and not "12.00".\n\n       NOTE: When operating in POSIX mode (such as with the --posix option), beware that locale settings  may  inter\xe2\x80\x90\n       fere  with  the  way decimal numbers are treated: the decimal separator of the numbers you are feeding to gawk\n       must conform to what your locale would expect, be it a comma (,) or a period (.).\n\n       Gawk performs comparisons as follows: If two variables are numeric, they are  compared  numerically.   If  one\n       value  is  numeric and the other has a string value that is a \xe2\x80\x9cnumeric string,\xe2\x80\x9d then comparisons are also done\n       numerically.  Otherwise, the numeric value is converted to a string and a string comparison is performed.  Two\n       strings are compared, of course, as strings.\n\n       Note  that  string  constants,  such as "57", are not numeric strings, they are string constants.  The idea of\n       \xe2\x80\x9cnumeric string\xe2\x80\x9d only applies to fields, getline input, FILENAME, ARGV elements, ENVIRON elements and the ele\xe2\x80\x90\n       ments  of  an  array  created  by split() or patsplit() that are numeric strings.  The basic idea is that user\n       input, and only user input, that looks numeric, should be treated that way.\n\n   Octal and Hexadecimal Constants\n       You may use C-style octal and hexadecimal constants in your AWK program source code.  For example,  the  octal\n       value 011 is equal to decimal 9, and the hexadecimal value 0x11 is equal to decimal 17.\n\n   String Constants\n       String  constants  in  AWK  are sequences of characters enclosed between double quotes (like "value").  Within\n       strings, certain escape sequences are recognized, as in C.  These are:\n\n       \\\\   A literal backslash.\n\n       \\a   The \xe2\x80\x9calert\xe2\x80\x9d character; usually the ASCII BEL character.\n\n       \\b   Backspace.\n\n       \\f   Form-feed.\n\n       \\n   Newline.\n\n       \\r   Carriage return.\n\n       \\t   Horizontal tab.\n\n       \\v   Vertical tab.\n\n       \\xhex digits\n            The character represented by the string of hexadecimal digits following the  \\x.   Up  to  two  following\n            hexadecimal  digits  are  considered part of the escape sequence.  E.g., "\\x1B" is the ASCII ESC (escape)\n            character.\n\n       \\ddd The character represented by the 1-, 2-, or 3-digit sequence of octal digits.  E.g., "\\033" is the  ASCII\n            ESC (escape) character.\n\n       \\c   The literal character c.\n\n       In compatibility mode, the characters represented by octal and hexadecimal escape sequences are treated liter\xe2\x80\x90\n       ally when used in regular expression constants.  Thus, /a\\52b/ is equivalent to /a\\*b/.\n\n   Regexp Constants\n       A regular expression constant is a sequence of characters enclosed between  forward  slashes  (like  /value/).\n       Regular expression matching is described more fully below; see Regular Expressions.\n\n       The  escape  sequences  described  earlier  may  also  be  used  inside  constant  regular  expressions (e.g.,\n       /[ \\t\\f\\n\\r\\v]/ matches whitespace characters).\n\n       Gawk   provides strongly typed regular expression constants. These are written with a leading @  symbol  (like\n              so:  @/value/).   Such  constants  may be assigned to scalars (variables, array elements) and passed to\n              user-defined functions. Variables that have been so assigned have regular expression type.\n\nPATTERNS AND ACTIONS\n       AWK is a line-oriented language.  The pattern comes  first,  and  then  the  action.   Action  statements  are\n       enclosed  in  {  and  }.  Either the pattern may be missing, or the action may be missing, but, of course, not\n       both.  If the pattern is missing, the action executes for every single record of input.  A missing  action  is\n       equivalent to\n\n              { print }\n\n       which prints the entire record.\n\n       Comments begin with the # character, and continue until the end of the line.  Empty lines may be used to sepa\xe2\x80\x90\n       rate statements.  Normally, a statement ends with a newline, however, this is not the case for lines ending in\n       a comma, {, ?, :, &&, or ||.  Lines ending in do or else also have their statements automatically continued on\n       the following line.  In other cases, a line can be continued by ending it with a \xe2\x80\x9c\\\xe2\x80\x9d, in which case  the  new\xe2\x80\x90\n       line is ignored.\n\n       Multiple statements may be put on one line by separating them with a \xe2\x80\x9c;\xe2\x80\x9d.  This applies to both the statements\n       within the action part of a pattern-action pair (the usual case), and to the pattern-action  statements  them\xe2\x80\x90\n       selves.\n\n   Patterns\n       AWK patterns may be one of the following:\n\n              BEGIN\n              END\n              BEGINFILE\n              ENDFILE\n              /regular expression/\n              relational expression\n              pattern && pattern\n              pattern || pattern\n              pattern ? pattern : pattern\n              (pattern)\n              ! pattern\n              pattern1, pattern2\n\n       BEGIN  and  END are two special kinds of patterns which are not tested against the input.  The action parts of\n       all BEGIN patterns are merged as if all the statements had been written in a single BEGIN rule.  They are exe\xe2\x80\x90\n       cuted  before  any  of  the input is read.  Similarly, all the END rules are merged, and executed when all the\n       input is exhausted (or when an exit statement is executed).  BEGIN and END patterns cannot  be  combined  with\n       other patterns in pattern expressions.  BEGIN and END patterns cannot have missing action parts.\n\n       BEGINFILE  and  ENDFILE  are  additional  special  patterns whose bodies are executed before reading the first\n       record of each command line input file and after reading the last record of each file.  Inside  the  BEGINFILE\n       rule,  the  value  of ERRNO is the empty string if the file was opened successfully.  Otherwise, there is some\n       problem with the file and the code should use nextfile to skip it. If that is  not  done,  gawk  produces  its\n       usual fatal error for files that cannot be opened.\n\n       For /regular expression/ patterns, the associated statement is executed for each input record that matches the\n       regular expression.  Regular expressions are the same as those in egrep(1), and are summarized below.\n\n       A relational expression may use any of the operators defined below in the section on actions.  These generally\n       test whether certain fields match certain regular expressions.\n\n       The  &&,  ||,  and  !  operators are logical AND, logical OR, and logical NOT, respectively, as in C.  They do\n       short-circuit evaluation, also as in C, and are used for combining more primitive pattern expressions.  As  in\n       most languages, parentheses may be used to change the order of evaluation.\n\n       The  ?: operator is like the same operator in C.  If the first pattern is true then the pattern used for test\xe2\x80\x90\n       ing is the second pattern, otherwise it is the third.  Only one of the second and third patterns is evaluated.\n\n       The pattern1, pattern2 form of an expression is called a range pattern.  It matches all input records starting\n       with  a record that matches pattern1, and continuing until a record that matches pattern2, inclusive.  It does\n       not combine with any other sort of pattern expression.\n\n   Regular Expressions\n       Regular expressions are the extended kind found in egrep.  They are composed of characters as follows:\n\n       c          Matches the non-metacharacter c.\n\n       \\c         Matches the literal character c.\n\n       .          Matches any character including newline.\n\n       ^          Matches the beginning of a string.\n\n       $          Matches the end of a string.\n\n       [abc...]   A character list: matches any of the characters abc....  You may include a range of  characters  by\n                  separating them with a dash.\n\n       [^abc...]  A negated character list: matches any character except abc....\n\n       r1|r2      Alternation: matches either r1 or r2.\n\n       r1r2       Concatenation: matches r1, and then r2.\n\n       r+         Matches one or more r\'s.\n\n       r*         Matches zero or more r\'s.\n\n       r?         Matches zero or one r\'s.\n\n       (r)        Grouping: matches r.\n\n       r{n}\n       r{n,}\n       r{n,m}     One  or  two  numbers  inside  braces denote an interval expression.  If there is one number in the\n                  braces, the preceding regular expression r is repeated n times.  If there are two numbers separated\n                  by  a  comma,  r  is  repeated n to m times.  If there is one number followed by a comma, then r is\n                  repeated at least n times.\n\n       \\y         Matches the empty string at either the beginning or the end of a word.\n\n       \\B         Matches the empty string within a word.\n\n       \\<         Matches the empty string at the beginning of a word.\n\n       \\>         Matches the empty string at the end of a word.\n\n       \\s         Matches any whitespace character.\n\n       \\S         Matches any nonwhitespace character.\n\n       \\w         Matches any word-constituent character (letter, digit, or underscore).\n\n       \\W         Matches any character that is not word-constituent.\n\n       \\`         Matches the empty string at the beginning of a buffer (string).\n\n       \\\'         Matches the empty string at the end of a buffer.\n\n       The escape sequences that are valid in string constants (see String  Constants)  are  also  valid  in  regular\n       expressions.\n\n       Character classes are a feature introduced in the POSIX standard.  A character class is a special notation for\n       describing lists of characters that have a specific attribute, but where the actual characters themselves  can\n       vary  from  country to country and/or from character set to character set.  For example, the notion of what is\n       an alphabetic character differs in the USA and in France.\n\n       A character class is only valid in a regular expression inside the brackets of a  character  list.   Character\n       classes consist of [:, a keyword denoting the class, and :].  The character classes defined by the POSIX stan\xe2\x80\x90\n       dard are:\n\n       [:alnum:]  Alphanumeric characters.\n\n       [:alpha:]  Alphabetic characters.\n\n       [:blank:]  Space or tab characters.\n\n       [:cntrl:]  Control characters.\n\n       [:digit:]  Numeric characters.\n\n       [:graph:]  Characters that are both printable and visible.  (A space is printable, but not visible, while an a\n                  is both.)\n\n       [:lower:]  Lowercase alphabetic characters.\n\n       [:print:]  Printable characters (characters that are not control characters.)\n\n       [:punct:]  Punctuation  characters (characters that are not letter, digits, control characters, or space char\xe2\x80\x90\n                  acters).\n\n       [:space:]  Space characters (such as space, tab, and formfeed, to name a few).\n\n       [:upper:]  Uppercase alphabetic characters.\n\n       [:xdigit:] Characters that are hexadecimal digits.\n\n       For example, before the POSIX standard, to  match  alphanumeric  characters,  you  would  have  had  to  write\n       /[A-Za-z0-9]/.  If your character set had other alphabetic characters in it, this would not match them, and if\n       your character set collated differently from ASCII, this might not even match the ASCII  alphanumeric  charac\xe2\x80\x90\n       ters.   With  the  POSIX  character  classes, you can write /[[:alnum:]]/, and this matches the alphabetic and\n       numeric characters in your character set, no matter what it is.\n\n       Two additional special sequences can appear in character lists.  These  apply  to  non-ASCII  character  sets,\n       which  can  have single symbols (called collating elements) that are represented with more than one character,\n       as well as several characters that are equivalent for collating, or sorting, purposes.  (E.g.,  in  French,  a\n       plain \xe2\x80\x9ce\xe2\x80\x9d and a grave-accented \xe2\x80\x9c`\xe2\x80\x9d are equivalent.)\n\n       Collating Symbols\n              A  collating  symbol is a multi-character collating element enclosed in [.  and .].  For example, if ch\n              is a collating element, then [[.ch.]]  is a regular expression that  matches  this  collating  element,\n              while [ch] is a regular expression that matches either c or h.\n\n       Equivalence Classes\n              An  equivalence class is a locale-specific name for a list of characters that are equivalent.  The name\n              is enclosed in [= and =].  For example, the name e might be used to represent all of \xe2\x80\x9ce\xe2\x80\x9d, \xe2\x80\x9c\xc2\xb4\xe2\x80\x9d, and \xe2\x80\x9c`\xe2\x80\x9d.\n              In this case, [[=e=]] is a regular expression that matches any of e, \xc2\xb4, or `.\n\n       These  features  are  very valuable in non-English speaking locales.  The library functions that gawk uses for\n       regular expression matching currently only recognize POSIX character classes; they do not recognize  collating\n       symbols or equivalence classes.\n\n       The  \\y,  \\B,  \\<, \\>, \\s, \\S, \\w, \\W, \\`, and \\\' operators are specific to gawk; they are extensions based on\n       facilities in the GNU regular expression libraries.\n\n       The various command line options control how gawk interprets characters in regular expressions.\n\n       No options\n              In the default case, gawk provides all the facilities of POSIX regular expressions and the GNU  regular\n              expression operators described above.\n\n       --posix\n              Only  POSIX  regular expressions are supported, the GNU operators are not special.  (E.g., \\w matches a\n              literal w).\n\n       --traditional\n              Traditional UNIX awk regular expressions are matched.  The GNU operators are not special, and  interval\n              expressions  are  not  available.   Characters  described by octal and hexadecimal escape sequences are\n              treated literally, even if they represent regular expression metacharacters.\n\n       --re-interval\n              Allow interval expressions in regular expressions, even if --traditional has been provided.\n\n   Actions\n       Action statements are enclosed in braces, { and }.  Action statements consist of the usual assignment,  condi\xe2\x80\x90\n       tional,  and  looping statements found in most languages.  The operators, control statements, and input/output\n       statements available are patterned after those in C.\n\n   Operators\n       The operators in AWK, in order of decreasing precedence, are:\n\n       (...)       Grouping\n\n       $           Field reference.\n\n       ++ --       Increment and decrement, both prefix and postfix.\n\n       ^           Exponentiation (** may also be used, and **= for the assignment operator).\n\n       + - !       Unary plus, unary minus, and logical negation.\n\n       * / %       Multiplication, division, and modulus.\n\n       + -         Addition and subtraction.\n\n       space       String concatenation.\n\n       |   |&      Piped I/O for getline, print, and printf.\n\n       < > <= >= == !=\n                   The regular relational operators.\n\n       ~ !~        Regular expression match, negated match.  NOTE: Do not use a constant regular  expression  (/foo/)\n                   on  the left-hand side of a ~ or !~.  Only use one on the right-hand side.  The expression /foo/ ~\n                   exp has the same meaning as (($0 ~ /foo/) ~ exp).  This is usually not what you want.\n\n       in          Array membership.\n\n       &&          Logical AND.\n\n       ||          Logical OR.\n\n       ?:          The C conditional expression.  This has the form expr1 ? expr2 : expr3.  If  expr1  is  true,  the\n                   value  of  the  expression is expr2, otherwise it is expr3.  Only one of expr2 and expr3 is evalu\xe2\x80\x90\n                   ated.\n\n       = += -= *= /= %= ^=\n                   Assignment.  Both absolute assignment (var = value) and operator-assignment (the other forms)  are\n                   supported.\n\n   Control Statements\n       The control statements are as follows:\n\n              if (condition) statement [ else statement ]\n              while (condition) statement\n              do statement while (condition)\n              for (expr1; expr2; expr3) statement\n              for (var in array) statement\n              break\n              continue\n              delete array[index]\n              delete array\n              exit [ expression ]\n              { statements }\n              switch (expression) {\n              case value|regex : statement\n              ...\n              [ default: statement ]\n              }\n\n   I/O Statements\n       The input/output statements are as follows:\n\n       close(file [, how])   Close  file,  pipe  or coprocess.  The optional how should only be used when closing one\n                             end of a two-way pipe to a coprocess.  It must be a string value, either "to" or "from".\n\n       getline               Set $0 from next input record; set NF, NR, FNR, RT.\n\n       getline <file         Set $0 from next record of file; set NF, RT.\n\n       getline var           Set var from next input record; set NR, FNR, RT.\n\n       getline var <file     Set var from next record of file, RT.\n\n       command | getline [var]\n                             Run command piping the output either into $0 or var, as above, and RT.\n\n       command |& getline [var]\n                             Run command as a coprocess piping the output either into $0 or var, as  above,  and  RT.\n                             Coprocesses  are  a  gawk extension.  (command can also be a socket.  See the subsection\n                             Special File Names, below.)\n\n       next                  Stop processing the current input record.  The next input record is read and  processing\n                             starts  over  with  the  first pattern in the AWK program.  Upon reaching the end of the\n                             input data, gawk executes any END rule(s).\n\n       nextfile              Stop processing the current input file.  The next input record read comes from the  next\n                             input  file.   FILENAME and ARGIND are updated, FNR is reset to 1, and processing starts\n                             over with the first pattern in the AWK program.  Upon reaching  the  end  of  the  input\n                             data, gawk executes any ENDFILE and END rule(s).\n\n       print                 Print the current record.  The output record is terminated with the value of ORS.\n\n       print expr-list       Print expressions.  Each expression is separated by the value of OFS.  The output record\n                             is terminated with the value of ORS.\n\n       print expr-list >file Print expressions on file.  Each expression is separated by the value of OFS.  The  out\xe2\x80\x90\n                             put record is terminated with the value of ORS.\n\n       printf fmt, expr-list Format and print.  See The printf Statement, below.\n\n       printf fmt, expr-list >file\n                             Format and print on file.\n\n       system(cmd-line)      Execute the command cmd-line, and return the exit status.  (This may not be available on\n                             non-POSIX systems.)  See GAWK: Effective AWK Programming for the  full  details  on  the\n                             exit status.\n\n       fflush([file])        Flush any buffers associated with the open output file or pipe file.  If file is missing\n                             or if it is the null string, then flush all open output files and pipes.\n\n       Additional output redirections are allowed for print and printf.\n\n       print ... >> file\n              Appends output to the file.\n\n       print ... | command\n              Writes on a pipe.\n\n       print ... |& command\n              Sends data to a coprocess or socket.  (See also the subsection Special File Names, below.)\n\n       The getline command returns 1 on success, zero on end of file, and -1 on an  error.   If  the  errno(3)  value\n       indicates  that  the  I/O operation may be retried, and PROCINFO["input", "RETRY"] is set, then -2 is returned\n       instead of -1, and further calls to getline may be attempted.  Upon  an  error,  ERRNO  is  set  to  a  string\n       describing the problem.\n\n       NOTE: Failure in opening a two-way socket results in a non-fatal error being returned to the calling function.\n       If using a pipe, coprocess, or socket to getline, or from print or printf within a loop, you must use  close()\n       to  create new instances of the command or socket.  AWK does not automatically close pipes, sockets, or copro\xe2\x80\x90\n       cesses when they return EOF.\n\n   The printf Statement\n       The AWK versions of the printf statement and sprintf() function (see below) accept  the  following  conversion\n       specification formats:\n\n       %c      A single character.  If the argument used for %c is numeric, it is treated as a character and printed.\n               Otherwise, the argument is assumed to be a string, and the only first  character  of  that  string  is\n               printed.\n\n       %d, %i  A decimal number (the integer part).\n\n       %e, %E  A floating point number of the form [-]d.dddddde[+-]dd.  The %E format uses E instead of e.\n\n       %f, %F  A floating point number of the form [-]ddd.dddddd.  If the system library supports it, %F is available\n               as well. This is like %f, but uses capital letters for special \xe2\x80\x9cnot a number\xe2\x80\x9d and  \xe2\x80\x9cinfinity\xe2\x80\x9d  values.\n               If %F is not available, gawk uses %f.\n\n       %g, %G  Use  %e  or  %f conversion, whichever is shorter, with nonsignificant zeros suppressed.  The %G format\n               uses %E instead of %e.\n\n       %o      An unsigned octal number (also an integer).\n\n       %u      An unsigned decimal number (again, an integer).\n\n       %s      A character string.\n\n       %x, %X  An unsigned hexadecimal number (an integer).  The %X format uses ABCDEF instead of abcdef.\n\n       %%      A single % character; no argument is converted.\n\n       Optional, additional parameters may lie between the % and the control letter:\n\n       count$ Use the count\'th argument at this point in the formatting.  This is called a positional  specifier  and\n              is  intended primarily for use in translated versions of format strings, not in the original text of an\n              AWK program.  It is a gawk extension.\n\n       -      The expression should be left-justified within its field.\n\n       space  For numeric conversions, prefix positive values with a space, and negative values with a minus sign.\n\n       +      The plus sign, used before the width modifier (see below), says to always supply  a  sign  for  numeric\n              conversions, even if the data to be formatted is positive.  The + overrides the space modifier.\n\n       #      Use  an  \xe2\x80\x9calternate form\xe2\x80\x9d for certain control letters.  For %o, supply a leading zero.  For %x, and %X,\n              supply a leading 0x or 0X for a nonzero result.  For %e, %E, %f and %F, the result  always  contains  a\n              decimal point.  For %g, and %G, trailing zeros are not removed from the result.\n\n       0      A  leading 0 (zero) acts as a flag, indicating that output should be padded with zeroes instead of spa\xe2\x80\x90\n              ces.  This applies only to the numeric output formats.  This flag only has an  effect  when  the  field\n              width is wider than the value to be printed.\n\n       \'      A single quote character instructs gawk to insert the locale\'s thousands-separator character into deci\xe2\x80\x90\n              mal numbers, and to also use the locale\'s decimal point character with floating  point  formats.   This\n              requires correct locale support in the C library and in the definition of the current locale.\n\n       width  The  field should be padded to this width.  The field is normally padded with spaces.  With the 0 flag,\n              it is padded with zeroes.\n\n       .prec  A number that specifies the precision to use when printing.  For the %e, %E, %f and %F,  formats,  this\n              specifies  the number of digits you want printed to the right of the decimal point.  For the %g, and %G\n              formats, it specifies the maximum number of significant digits.  For the %d, %i, %o,  %u,  %x,  and  %X\n              formats,  it  specifies the minimum number of digits to print.  For %s, it specifies the maximum number\n              of characters from the string that should be printed.\n\n       The dynamic width and prec capabilities of the ISO C printf() routines are supported.  A * in place of  either\n       the  width  or  prec  specifications  causes  their  values  to  be  taken from the argument list to printf or\n       sprintf().  To use a positional specifier with a dynamic width or precision, supply the count$ after the *  in\n       the format string.  For example, "%3$*2$.*1$s".\n\n   Special File Names\n       When  doing  I/O  redirection from either print or printf into a file, or via getline from a file, gawk recog\xe2\x80\x90\n       nizes certain special filenames internally.  These filenames allow access to open file  descriptors  inherited\n       from gawk\'s parent process (usually the shell).  These file names may also be used on the command line to name\n       data files.  The filenames are:\n\n       -           The standard input.\n\n       /dev/stdin  The standard input.\n\n       /dev/stdout The standard output.\n\n       /dev/stderr The standard error output.\n\n       /dev/fd/n   The file associated with the open file descriptor n.\n\n       These are particularly useful for error messages.  For example:\n\n              print "You blew it!" > "/dev/stderr"\n\n       whereas you would otherwise have to use\n\n              print "You blew it!" | "cat 1>&2"\n\n       The following special filenames may be used with the |& coprocess operator for creating TCP/IP network connec\xe2\x80\x90\n       tions:\n\n       /inet/tcp/lport/rhost/rport\n       /inet4/tcp/lport/rhost/rport\n       /inet6/tcp/lport/rhost/rport\n              Files  for  a  TCP/IP  connection on local port lport to remote host rhost on remote port rport.  Use a\n              port of 0 to have the system pick a port.  Use /inet4 to force an IPv4 connection, and /inet6 to  force\n              an IPv6 connection.  Plain /inet uses the system default (most likely IPv4).\n\n       /inet/udp/lport/rhost/rport\n       /inet4/udp/lport/rhost/rport\n       /inet6/udp/lport/rhost/rport\n              Similar, but use UDP/IP instead of TCP/IP.\n\n   Numeric Functions\n       AWK has the following built-in arithmetic functions:\n\n       atan2(y, x)   Return the arctangent of y/x in radians.\n\n       cos(expr)     Return the cosine of expr, which is in radians.\n\n       exp(expr)     The exponential function.\n\n       int(expr)     Truncate to integer.\n\n       log(expr)     The natural logarithm function.\n\n       rand()        Return a random number N, between zero and one, such that 0 \xe2\x89\xa4 N < 1.\n\n       sin(expr)     Return the sine of expr, which is in radians.\n\n       sqrt(expr)    Return the square root of expr.\n\n       srand([expr]) Use  expr as the new seed for the random number generator.  If no expr is provided, use the time\n                     of day.  Return the previous seed for the random number generator.\n\n   String Functions\n       Gawk has the following built-in string functions:\n\n       asort(s [, d [, how] ]) Return the number of elements in the source array s.  Sort the  contents  of  s  using\n                               gawk\'s normal rules for comparing values, and replace the indices of the sorted values\n                               s with sequential integers starting with 1. If the optional  destination  array  d  is\n                               specified,  first  duplicate  s  into  d,  and then sort d, leaving the indices of the\n                               source array s unchanged. The optional string how controls the direction and the  com\xe2\x80\x90\n                               parison   mode.    Valid   values   for   how   are  any  of  the  strings  valid  for\n                               PROCINFO["sorted_in"].  It can also be the name of a user-defined comparison  function\n                               as described in PROCINFO["sorted_in"].\n\n       asorti(s [, d [, how] ])\n                               Return the number of elements in the source array s.  The behavior is the same as that\n                               of asort(), except that the array indices are used for sorting, not the array  values.\n                               When  done, the array is indexed numerically, and the values are those of the original\n                               indices.  The original values are lost; thus provide a second array  if  you  wish  to\n                               preserve  the  original.   The  purpose  of  the  optional  string  how is the same as\n                               described previously for asort().\n\n       gensub(r, s, h [, t])   Search the target string t for matches of the regular expression r.  If h is a  string\n                               beginning with g or G, then replace all matches of r with s.  Otherwise, h is a number\n                               indicating which match of r to replace.  If t is not supplied, use $0 instead.  Within\n                               the  replacement  text s, the sequence \\n, where n is a digit from 1 to 9, may be used\n                               to indicate just the text that matched  the  n\'th  parenthesized  subexpression.   The\n                               sequence \\0 represents the entire matched text, as does the character &.  Unlike sub()\n                               and gsub(), the modified string is returned as the result of  the  function,  and  the\n                               original target string is not changed.\n\n       gsub(r, s [, t])        For  each  substring matching the regular expression r in the string t, substitute the\n                               string s, and return the number of substitutions.  If t is not supplied, use $0.  An &\n                               in  the  replacement text is replaced with the text that was actually matched.  Use \\&\n                               to get a literal &.  (This must be typed as "\\\\&"; see GAWK: Effective AWK Programming\n                               for a fuller discussion of the rules for ampersands and backslashes in the replacement\n                               text of sub(), gsub(), and gensub().)\n\n       index(s, t)             Return the index of the string t in the string s, or zero if t is not present.   (This\n                               implies  that  character  indices  start at one.)  It is a fatal error to use a regexp\n                               constant for t.\n\n       length([s])             Return the length of the string s, or the length of $0 if s is  not  supplied.   As  a\n                               non-standard  extension,  with  an array argument, length() returns the number of ele\xe2\x80\x90\n                               ments in the array.\n\n       match(s, r [, a])       Return the position in s where the regular expression r occurs, or zero if  r  is  not\n                               present,  and  set  the values of RSTART and RLENGTH.  Note that the argument order is\n                               the same as for the ~ operator: str ~ re.  If array a is provided, a  is  cleared  and\n                               then elements 1 through n are filled with the portions of s that match the correspond\xe2\x80\x90\n                               ing parenthesized subexpression in r.  The zero\'th element of a contains  the  portion\n                               of  s  matched by the entire regular expression r.  Subscripts a[n, "start"], and a[n,\n                               "length"] provide the starting index in the string and length  respectively,  of  each\n                               matching substring.\n\n       patsplit(s, a [, r [, seps] ])\n                               Split  the  string  s  into  the  array a and the separators array seps on the regular\n                               expression r, and return the number of fields.  Element values are the portions  of  s\n                               that  matched  r.   The  value of seps[i] is the possibly null separator that appeared\n                               after a[i].  The value of seps[0] is the possibly null leading  separator.   If  r  is\n                               omitted,  FPAT  is  used instead.  The arrays a and seps are cleared first.  Splitting\n                               behaves identically to field splitting with FPAT, described above.\n\n       split(s, a [, r [, seps] ])\n                               Split the string s into the array a and the  separators  array  seps  on  the  regular\n                               expression  r,  and return the number of fields.  If r is omitted, FS is used instead.\n                               The arrays a and seps are cleared first.  seps[i] is the field separator matched by  r\n                               between  a[i]  and  a[i+1].  If r is a single space, then leading whitespace in s goes\n                               into the extra array element seps[0] and trailing whitespace goes into the extra array\n                               element  seps[n],  where  n  is  the  return value of split(s, a, r, seps).  Splitting\n                               behaves identically to field splitting, described above.\n\n       sprintf(fmt, expr-list) Print expr-list according to fmt, and return the resulting string.\n\n       strtonum(str)           Examine str, and return its numeric value.  If str begins with a leading 0,  treat  it\n                               as  an octal number.  If str begins with a leading 0x or 0X, treat it as a hexadecimal\n                               number.  Otherwise, assume it is a decimal number.\n\n       sub(r, s [, t])         Just like gsub(), but replace only the first matching substring.  Return  either  zero\n                               or one.\n\n       substr(s, i [, n])      Return the at most n-character substring of s starting at i.  If n is omitted, use the\n                               rest of s.\n\n       tolower(str)            Return a copy of the string str, with all the uppercase characters in  str  translated\n                               to  their  corresponding  lowercase  counterparts.  Non-alphabetic characters are left\n                               unchanged.\n\n       toupper(str)            Return a copy of the string str, with all the lowercase characters in  str  translated\n                               to  their  corresponding  uppercase  counterparts.  Non-alphabetic characters are left\n                               unchanged.\n\n       Gawk is multibyte aware.  This means that index(), length(), substr() and match() all work in terms of charac\xe2\x80\x90\n       ters, not bytes.\n\n   Time Functions\n       Since  one  of  the  primary uses of AWK programs is processing log files that contain time stamp information,\n       gawk provides the following functions for obtaining time stamps and formatting them.\n\n       mktime(datespec [, utc-flag])\n                 Turn datespec into a time stamp of the same form as returned by systime(), and  return  the  result.\n                 The  datespec is a string of the form YYYY MM DD HH MM SS[ DST].  The contents of the string are six\n                 or seven numbers representing respectively the full year including century, the month from 1 to  12,\n                 the  day  of  the month from 1 to 31, the hour of the day from 0 to 23, the minute from 0 to 59, the\n                 second from 0 to 60, and an optional daylight saving flag.  The values of these numbers need not  be\n                 within  the  ranges specified; for example, an hour of -1 means 1 hour before midnight.  The origin-\n                 zero Gregorian calendar is assumed, with year 0 preceding year 1 and year -1 preceding year  0.   If\n                 utc-flag  is  present  and  is non-zero or non-null, the time is assumed to be in the UTC time zone;\n                 otherwise, the time is assumed to be in the local time zone.  If the DST  daylight  saving  flag  is\n                 positive,  the  time is assumed to be daylight saving time; if zero, the time is assumed to be stan\xe2\x80\x90\n                 dard time; and if negative (the default), mktime() attempts to  determine  whether  daylight  saving\n                 time  is  in  effect for the specified time.  If datespec does not contain enough elements or if the\n                 resulting time is out of range, mktime() returns -1.\n\n       strftime([format [, timestamp[, utc-flag]]])\n                 Format timestamp according to the specification in format.  If utc-flag is present and  is  non-zero\n                 or  non-null,  the result is in UTC, otherwise the result is in local time.  The timestamp should be\n                 of the same form as returned by systime().  If timestamp is missing, the  current  time  of  day  is\n                 used.   If  format  is  missing,  a default format equivalent to the output of date(1) is used.  The\n                 default format is available in PROCINFO["strftime"].  See the specification for the strftime() func\xe2\x80\x90\n                 tion in ISO C for the format conversions that are guaranteed to be available.\n\n       systime() Return  the current time of day as the number of seconds since the Epoch (1970-01-01 00:00:00 UTC on\n                 POSIX systems).\n\n   Bit Manipulations Functions\n       Gawk supplies the following bit manipulation functions.  They work  by  converting  double-precision  floating\n       point  values  to  uintmax_t  integers,  doing  the operation, and then converting the result back to floating\n       point.\n\n       NOTE: Passing negative operands to any of these functions causes a fatal error.\n\n       The functions are:\n\n       and(v1, v2 [, ...]) Return the bitwise AND of the values provided in the argument  list.   There  must  be  at\n                           least two.\n\n       compl(val)          Return the bitwise complement of val.\n\n       lshift(val, count)  Return the value of val, shifted left by count bits.\n\n       or(v1, v2 [, ...])  Return the bitwise OR of the values provided in the argument list.  There must be at least\n                           two.\n\n       rshift(val, count)  Return the value of val, shifted right by count bits.\n\n       xor(v1, v2 [, ...]) Return the bitwise XOR of the values provided in the argument  list.   There  must  be  at\n                           least two.\n\n   Type Functions\n       The following function is for use with multidimensional arrays.\n\n       isarray(x)\n              Return true if x is an array, false otherwise.\n\n       You can tell the type of any variable or array element with the following function:\n\n       typeof(x)\n              Return  a  string  indicating  the  type  of x.  The string will be one of "array", "number", "regexp",\n              "string", "strnum", or "undefined".\n\n   Internationalization Functions\n       The following functions may be used from within your AWK program for translating  strings  at  run-time.   For\n       full details, see GAWK: Effective AWK Programming.\n\n       bindtextdomain(directory [, domain])\n              Specify the directory where gawk looks for the .gmo files, in case they will not or cannot be placed in\n              the ``standard\'\' locations (e.g., during testing).  It returns the directory where domain is ``bound.\'\'\n              The default domain is the value of TEXTDOMAIN.  If directory is the null string (""), then  bindtextdo\xe2\x80\x90\n              main() returns the current binding for the given domain.\n\n       dcgettext(string [, domain [, category]])\n              Return the translation of string in text domain domain for locale category category.  The default value\n              for domain is the current value of TEXTDOMAIN.  The default value for category is "LC_MESSAGES".\n              If you supply a value for category, it must be a string equal to one of  the  known  locale  categories\n              described  in  GAWK: Effective AWK Programming.  You must also supply a text domain.  Use TEXTDOMAIN if\n              you want to use the current domain.\n\n       dcngettext(string1, string2, number [, domain [, category]])\n              Return the plural form used for number of the translation of string1 and string2 in text domain  domain\n              for  locale  category  category.  The default value for domain is the current value of TEXTDOMAIN.  The\n              default value for category is "LC_MESSAGES".\n              If you supply a value for category, it must be a string equal to one of  the  known  locale  categories\n              described  in  GAWK: Effective AWK Programming.  You must also supply a text domain.  Use TEXTDOMAIN if\n              you want to use the current domain.\n\nUSER-DEFINED FUNCTIONS\n       Functions in AWK are defined as follows:\n\n              function name(parameter list) { statements }\n\n       Functions execute when they are called from within expressions in either patterns or actions.  Actual  parame\xe2\x80\x90\n       ters  supplied  in  the  function call are used to instantiate the formal parameters declared in the function.\n       Arrays are passed by reference, other variables are passed by value.\n\n       Since functions were not originally part of the AWK language, the provision  for  local  variables  is  rather\n       clumsy:  They  are  declared  as  extra parameters in the parameter list.  The convention is to separate local\n       variables from real parameters by extra spaces in the parameter list.  For example:\n\n              function  f(p, q,     a, b)   # a and b are local\n              {\n                   ...\n              }\n\n              /abc/     { ... ; f(1, 2) ; ... }\n\n       The left parenthesis in a function call is required to immediately  follow  the  function  name,  without  any\n       intervening  whitespace.  This avoids a syntactic ambiguity with the concatenation operator.  This restriction\n       does not apply to the built-in functions listed above.\n\n       Functions may call each other and may be recursive.  Function parameters used as local variables are  initial\xe2\x80\x90\n       ized to the null string and the number zero upon function invocation.\n\n       Use  return expr to return a value from a function.  The return value is undefined if no value is provided, or\n       if the function returns by \xe2\x80\x9cfalling off\xe2\x80\x9d the end.\n\n       As a gawk extension, functions may be called indirectly. To do this, assign the name of  the  function  to  be\n       called, as a string, to a variable.  Then use the variable as if it were the name of a function, prefixed with\n       an @ sign, like so:\n              function myfunc()\n              {\n                   print "myfunc called"\n                   ...\n              }\n\n              {    ...\n                   the_func = "myfunc"\n                   @the_func()    # call through the_func to myfunc\n                   ...\n              }\n       As of version 4.1.2, this works with user-defined functions, built-in functions, and extension functions.\n\n       If --lint has been provided, gawk warns about calls to undefined functions at parse time, instead  of  at  run\n       time.  Calling an undefined function at run time is a fatal error.\n\n       The word func may be used in place of function, although this is deprecated.\n\nDYNAMICALLY LOADING NEW FUNCTIONS\n       You  can dynamically add new built-in functions to the running gawk interpreter with the @load statement.  The\n       full details are beyond the scope of this manual page; see GAWK: Effective AWK Programming.\n\nSIGNALS\n       The gawk profiler accepts two signals.  SIGUSR1 causes it to dump a profile and function  call  stack  to  the\n       profile file, which is either awkprof.out, or whatever file was named with the --profile option.  It then con\xe2\x80\x90\n       tinues to run.  SIGHUP causes gawk to dump the profile and function call stack and then exit.\n\nINTERNATIONALIZATION\n       String constants are sequences of characters enclosed in double quotes.  In non-English speaking environments,\n       it is possible to mark strings in the AWK program as requiring translation to the local natural language. Such\n       strings are marked in the AWK program with a leading underscore (\xe2\x80\x9c_\xe2\x80\x9d).  For example,\n\n              gawk \'BEGIN { print "hello, world" }\'\n\n       always prints hello, world.  But,\n\n              gawk \'BEGIN { print _"hello, world" }\'\n\n       might print bonjour, monde in France.\n\n       There are several steps involved in producing and running a localizable AWK program.\n\n       1.  Add a BEGIN action to assign a value to the TEXTDOMAIN variable to set the text domain to a  name  associ\xe2\x80\x90\n           ated with your program:\n\n                BEGIN { TEXTDOMAIN = "myprog" }\n\n           This  allows  gawk  to  find the .gmo file associated with your program.  Without this step, gawk uses the\n           messages text domain, which likely does not contain translations for your program.\n\n       2.  Mark all strings that should be translated with leading underscores.\n\n       3.  If necessary, use the dcgettext() and/or bindtextdomain() functions in your program, as appropriate.\n\n       4.  Run gawk --gen-pot -f myprog.awk > myprog.pot to generate a .pot file for your program.\n\n       5.  Provide appropriate translations, and build and install the corresponding .gmo files.\n\n       The internationalization features are described in full detail in GAWK: Effective AWK Programming.\n\nPOSIX COMPATIBILITY\n       A primary goal for gawk is compatibility with the POSIX standard, as well as with the latest version of  Brian\n       Kernighan\'s  awk.   To this end, gawk incorporates the following user visible features which are not described\n       in the AWK book, but are part of the Brian Kernighan\'s version of awk, and are in the POSIX standard.\n\n       The book indicates that command line variable assignment happens when awk would otherwise open the argument as\n       a  file, which is after the BEGIN rule is executed.  However, in earlier implementations, when such an assign\xe2\x80\x90\n       ment appeared before any file names, the assignment would happen before the BEGIN rule was run.   Applications\n       came  to depend on this \xe2\x80\x9cfeature.\xe2\x80\x9d  When awk was changed to match its documentation, the -v option for assign\xe2\x80\x90\n       ing variables before program execution was added to accommodate applications that depended upon the old behav\xe2\x80\x90\n       ior.  (This feature was agreed upon by both the Bell Laboratories and the GNU developers.)\n\n       When processing arguments, gawk uses the special option \xe2\x80\x9c--\xe2\x80\x9d to signal the end of arguments.  In compatibility\n       mode, it warns about but otherwise ignores undefined options.  In normal operation, such arguments are  passed\n       on to the AWK program for it to process.\n\n       The  AWK  book  does not define the return value of srand().  The POSIX standard has it return the seed it was\n       using, to allow keeping track of random number sequences.  Therefore srand() in gawk also returns its  current\n       seed.\n\n       Other  features  are:  The use of multiple -f options (from MKS awk); the ENVIRON array; the \\a, and \\v escape\n       sequences (done originally in gawk and fed back into the Bell Laboratories version); the tolower()  and  toup\xe2\x80\x90\n       per()  built-in  functions  (from  the  Bell Laboratories version); and the ISO C conversion specifications in\n       printf (done first in the Bell Laboratories version).\n\nHISTORICAL FEATURES\n       There is one feature of historical AWK implementations that gawk supports: It is possible to call the length()\n       built-in function not only with no argument, but even without parentheses!  Thus,\n\n              a = length     # Holy Algol 60, Batman!\n\n       is the same as either of\n\n              a = length()\n              a = length($0)\n\n       Using  this  feature  is  poor practice, and gawk issues a warning about its use if --lint is specified on the\n       command line.\n\nGNU EXTENSIONS\n       Gawk has a too-large number of extensions to POSIX awk.  They are described in this section.  All  the  exten\xe2\x80\x90\n       sions described here can be disabled by invoking gawk with the --traditional or --posix options.\n\n       The following features of gawk are not available in POSIX awk.\n\n       \xc2\xb7 No  path  search is performed for files named via the -f option.  Therefore the AWKPATH environment variable\n         is not special.\n\n       \xc2\xb7 There is no facility for doing file inclusion (gawk\'s @include mechanism).\n\n       \xc2\xb7 There is no facility for dynamically adding new functions written in C (gawk\'s @load mechanism).\n\n       \xc2\xb7 The \\x escape sequence.\n\n       \xc2\xb7 The ability to continue lines after ?  and :.\n\n       \xc2\xb7 Octal and hexadecimal constants in AWK programs.\n\n       \xc2\xb7 The ARGIND, BINMODE, ERRNO, LINT, PREC, ROUNDMODE, RT and TEXTDOMAIN variables are not special.\n\n       \xc2\xb7 The IGNORECASE variable and its side-effects are not available.\n\n       \xc2\xb7 The FIELDWIDTHS variable and fixed-width field splitting.\n\n       \xc2\xb7 The FPAT variable and field splitting based on field values.\n\n       \xc2\xb7 The FUNCTAB, SYMTAB, and PROCINFO arrays are not available.\n\n       \xc2\xb7 The use of RS as a regular expression.\n\n       \xc2\xb7 The special file names available for I/O redirection are not recognized.\n\n       \xc2\xb7 The |& operator for creating coprocesses.\n\n       \xc2\xb7 The BEGINFILE and ENDFILE special patterns are not available.\n\n       \xc2\xb7 The ability to split out individual characters using the null string as the value of FS, and  as  the  third\n         argument to split().\n\n       \xc2\xb7 An optional fourth argument to split() to receive the separator texts.\n\n       \xc2\xb7 The optional second argument to the close() function.\n\n       \xc2\xb7 The optional third argument to the match() function.\n\n       \xc2\xb7 The ability to use positional specifiers with printf and sprintf().\n\n       \xc2\xb7 The ability to pass an array to length().\n\n       \xc2\xb7 The  and(),  asort(),  asorti(),  bindtextdomain(),  compl(), dcgettext(), dcngettext(), gensub(), lshift(),\n         mktime(), or(), patsplit(), rshift(), strftime(), strtonum(), systime() and xor() functions.\n\n       \xc2\xb7 Localizable strings.\n\n       \xc2\xb7 Non-fatal I/O.\n\n       \xc2\xb7 Retryable I/O.\n\n       The AWK book does not define the return value of the close() function.  Gawk\'s close() returns the value  from\n       fclose(3),  or  pclose(3),  when  closing an output file or pipe, respectively.  It returns the process\'s exit\n       status when closing an input pipe.  The return value is -1 if the named file, pipe or coprocess was not opened\n       with a redirection.\n\n       When gawk is invoked with the --traditional option, if the fs argument to the -F option is \xe2\x80\x9ct\xe2\x80\x9d, then FS is set\n       to the tab character.  Note that typing gawk -F\\t ...  simply causes the shell to quote the \xe2\x80\x9ct,\xe2\x80\x9d and does  not\n       pass  \xe2\x80\x9c\\t\xe2\x80\x9d  to the -F option.  Since this is a rather ugly special case, it is not the default behavior.  This\n       behavior also does not occur if --posix has been specified.  To really get a tab character as the field  sepa\xe2\x80\x90\n       rator, it is best to use single quotes: gawk -F\'\\t\' ....\n\nENVIRONMENT VARIABLES\n       The  AWKPATH environment variable can be used to provide a list of directories that gawk searches when looking\n       for files named via the -f, --file, -i and --include options, and the  @include  directive.   If  the  initial\n       search fails, the path is searched again after appending .awk to the filename.\n\n       The AWKLIBPATH environment variable can be used to provide a list of directories that gawk searches when look\xe2\x80\x90\n       ing for files named via the -l and --load options.\n\n       The GAWK_READ_TIMEOUT environment variable can be used to specify a timeout in milliseconds for reading  input\n       from a terminal, pipe or two-way communication including sockets.\n\n       For  connection  to  a  remote  host  via  socket,  GAWK_SOCK_RETRIES  controls  the  number  of  retries, and\n       GAWK_MSEC_SLEEP and the interval between retries.  The interval is in milliseconds. On  systems  that  do  not\n       support usleep(3), the value is rounded up to an integral number of seconds.\n\n       If  POSIXLY_CORRECT  exists  in the environment, then gawk behaves exactly as if --posix had been specified on\n       the command line.  If --lint has been specified, gawk issues a warning message to this effect.\n\nEXIT STATUS\n       If the exit statement is used with a value, then gawk exits with the numeric value given to it.\n\n       Otherwise, if there were no problems during execution, gawk exits with the value of the C  constant  EXIT_SUC\xe2\x80\x90\n       CESS.  This is usually zero.\n\n       If an error occurs, gawk exits with the value of the C constant EXIT_FAILURE.  This is usually one.\n\n       If  gawk exits because of a fatal error, the exit status is 2.  On non-POSIX systems, this value may be mapped\n       to EXIT_FAILURE.\n\nVERSION INFORMATION\n       This man page documents gawk, version 4.2.\n\nAUTHORS\n       The original version of UNIX awk was designed and implemented by  Alfred  Aho,  Peter  Weinberger,  and  Brian\n       Kernighan of Bell Laboratories.  Brian Kernighan continues to maintain and enhance it.\n\n       Paul  Rubin  and Jay Fenlason, of the Free Software Foundation, wrote gawk, to be compatible with the original\n       version of awk distributed in Seventh Edition UNIX.  John Woods contributed a  number  of  bug  fixes.   David\n       Trueman,  with  contributions  from  Arnold  Robbins,  made  gawk compatible with the new version of UNIX awk.\n       Arnold Robbins is the current maintainer.\n\n       See GAWK: Effective AWK Programming for a full list of the contributors to gawk and its documentation.\n\n       See the README file in the gawk distribution for up-to-date information about maintainers and which ports  are\n       currently supported.\n\nBUG REPORTS\n       If  you  find  a  bug in gawk, please send electronic mail to bug-gawk@gnu.org.  Please include your operating\n       system and its revision, the version of gawk (from gawk --version), which C compiler you used to  compile  it,\n       and a test program and data that are as small as possible for reproducing the problem.\n\n       Before  sending  a bug report, please do the following things.  First, verify that you have the latest version\n       of gawk.  Many bugs (usually subtle ones) are fixed at each release, and if yours is out of date, the  problem\n       may  already  have  been  solved.   Second,  please see if setting the environment variable LC_ALL to LC_ALL=C\n       causes things to behave as you expect. If so, it\'s a locale issue, and  may  or  may  not  really  be  a  bug.\n       Finally,  please read this man page and the reference manual carefully to be sure that what you think is a bug\n       really is, instead of just a quirk in the language.\n\n       Whatever you do, do NOT post a bug report in comp.lang.awk.  While the gawk developers occasionally read  this\n       newsgroup,  posting bug reports there is an unreliable way to report bugs.  Instead, please use the electronic\n       mail addresses given above.  Really.\n\n       If you\'re using a GNU/Linux or BSD-based system, you may wish to submit a bug report to  the  vendor  of  your\n       distribution.   That\'s  fine,  but  please send a copy to the official email address as well, since there\'s no\n       guarantee that the bug report will be forwarded to the gawk maintainer.\n\nBUGS\n       The -F option is not necessary given the command line variable assignment feature; it remains only  for  back\xe2\x80\x90\n       wards compatibility.\n\nSEE ALSO\n       egrep(1),  sed(1),  getpid(2),  getppid(2),  getpgrp(2),  getuid(2),  geteuid(2),  getgid(2), getegid(2), get\xe2\x80\x90\n       groups(2), printf(3), strftime(3), usleep(3)\n\n       The AWK Programming Language, Alfred V. Aho, Brian W. Kernighan, Peter J.  Weinberger,  Addison-Wesley,  1988.\n       ISBN 0-201-07981-X.\n\n       GAWK: Effective AWK Programming, Edition 4.2, shipped with the gawk source.  The current version of this docu\xe2\x80\x90\n       ment is available online at https://www.gnu.org/software/gawk/manual.\n\n       The GNU gettext documentation, available online at https://www.gnu.org/software/gettext.\n\nEXAMPLES\n       Print and sort the login names of all users:\n\n            BEGIN     { FS = ":" }\n                 { print $1 | "sort" }\n\n       Count lines in a file:\n\n                 { nlines++ }\n            END  { print nlines }\n\n       Precede each line by its number in the file:\n\n            { print FNR, $0 }\n\n       Concatenate and line number (a variation on a theme):\n\n            { print NR, $0 }\n\n       Run an external command for particular lines of data:\n\n            tail -f access_log |\n            awk \'/myhome.html/ { system("nmap " $1 ">> logdir/myhome.html") }\'\n\nACKNOWLEDGEMENTS\n       Brian Kernighan provided valuable assistance during testing and debugging.  We thank him.\n\nCOPYING PERMISSIONS\n       Copyright \xc2\xa9 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003,  2004,  2005,  2007,\n       2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 Free Software Foundation, Inc.\n\n       Permission is granted to make and distribute verbatim copies of this manual page provided the copyright notice\n       and this permission notice are preserved on all copies.\n\n       Permission is granted to copy and distribute modified versions of this manual page under  the  conditions  for\n       verbatim  copying, provided that the entire resulting derived work is distributed under the terms of a permis\xe2\x80\x90\n       sion notice identical to this one.\n\n       Permission is granted to copy and distribute translations of this manual page into another language, under the\n       above  conditions  for  modified  versions,  except that this permission notice may be stated in a translation\n       approved by the Foundation.\n\nFree Software Foundation                             Feb 15 2018                                              GAWK(1)\n'
bwa
